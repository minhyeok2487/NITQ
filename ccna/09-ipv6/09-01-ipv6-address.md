# 09-01. IPv6 주소 체계

> 개요
IPv6 주소의 기본 구조, 표기법, 축약 규칙, IPv4와의 비교, 그리고 IPv6가 필요한 이유에 대한 면접 시나리오입니다.

---

### 면접관: "현재 운영 중인 네트워크에서 IPv4 주소가 부족해지고 있습니다. 상사가 IPv6 도입을 검토하라고 하는데, 먼저 IPv6 주소 체계에 대해 설명해 주시겠습니까?"

네, IPv6 주소 체계에 대해 설명드리겠습니다.

IPv6는 128비트 길이의 주소 체계로, IPv4의 32비트에 비해 훨씬 큰 주소 공간을 제공합니다. IPv4가 약 43억 개의 주소를 지원하는 반면, IPv6는 약 3.4 x 10^38개의 주소를 지원하여 사실상 무한에 가까운 주소 공간을 갖습니다.

IPv6 주소는 16진수(hexadecimal)로 표기하며, 8개의 16비트 그룹을 콜론(:)으로 구분합니다. 각 그룹은 4자리 16진수로 표현됩니다.

예를 들면 다음과 같습니다:

```
2001:0DB8:0000:0000:0000:0000:0000:0001
```

이 주소는 총 128비트이며, 각 그룹이 16비트씩 8개 그룹으로 구성됩니다.

---

### 면접관: "그 주소가 상당히 길어 보이는데, 축약하는 규칙이 있나요? 실무에서 어떻게 간단하게 표기합니까?"

네, IPv6에는 두 가지 주요 축약 규칙이 있습니다.

**규칙 1: 선행 0 생략 (Leading Zero Suppression)**

각 그룹에서 앞에 오는 0을 생략할 수 있습니다. 단, 그룹이 전부 0인 경우 최소 하나의 0은 남겨야 합니다.

```
원본:  2001:0DB8:0000:00A1:0000:0000:0000:0001
축약:  2001:DB8:0:A1:0:0:0:1
```

**규칙 2: 연속된 0 그룹 생략 (Double Colon ::)**

연속된 0으로만 이루어진 그룹을 `::`로 한 번만 축약할 수 있습니다. 주의할 점은 주소 내에서 `::`는 단 한 번만 사용 가능하다는 것입니다.

```
원본:  2001:0DB8:0000:0000:0000:0000:0000:0001
축약:  2001:DB8::1
```

만약 `::`를 두 번 사용하면 각 위치에 몇 개의 0 그룹이 있는지 알 수 없기 때문에 한 번만 허용됩니다.

실무에서 자주 보는 축약 예시를 정리하면 다음과 같습니다:

| 원본 주소 | 축약 주소 |
|-----------|-----------|
| 2001:0DB8:0000:0000:0000:0000:0000:0001 | 2001:DB8::1 |
| FE80:0000:0000:0000:0211:22FF:FE33:4455 | FE80::211:22FF:FE33:4455 |
| FF02:0000:0000:0000:0000:0000:0000:0001 | FF02::1 |
| 0000:0000:0000:0000:0000:0000:0000:0001 | ::1 (루프백) |

---

### 면접관: "IPv4와 IPv6를 비교해서 주요 차이점을 정리해 주시겠습니까?"

네, 주요 차이점을 표로 정리하겠습니다.

| 항목 | IPv4 | IPv6 |
|------|------|------|
| 주소 길이 | 32비트 | 128비트 |
| 주소 표기 | 10진수, 점 구분 (192.168.1.1) | 16진수, 콜론 구분 (2001:DB8::1) |
| 주소 개수 | 약 43억 개 | 약 3.4 x 10^38개 |
| 헤더 크기 | 가변적 (20~60바이트) | 고정 40바이트 |
| 브로드캐스트 | 지원 | 지원하지 않음 (멀티캐스트 사용) |
| ARP | 사용 | NDP(Neighbor Discovery Protocol) 사용 |
| NAT | 널리 사용 | 불필요 (충분한 주소 공간) |
| DHCP | DHCPv4 | SLAAC 또는 DHCPv6 |
| IPsec | 선택사항 | 기본 내장 지원 |
| 조각화 | 라우터에서 가능 | 출발지에서만 수행 |

특히 IPv6 헤더가 고정 40바이트로 단순화된 것이 중요합니다. IPv4에서는 Options 필드 때문에 헤더 크기가 가변적이었지만, IPv6에서는 확장 헤더(Extension Header) 방식으로 변경하여 기본 헤더를 단순화했습니다.

---

### 면접관: "IPv6 헤더가 단순화되었다고 하셨는데, 구체적으로 어떤 필드가 변경되었나요?"

IPv6 헤더에서 주요 변경 사항은 다음과 같습니다.

**제거된 필드:**
- **Header Length**: 고정 40바이트이므로 불필요
- **Identification / Flags / Fragment Offset**: 출발지에서만 조각화하므로 기본 헤더에서 제거
- **Header Checksum**: 상위 계층(TCP/UDP)에서 이미 체크섬을 수행하므로 제거하여 라우터 처리 속도 향상
- **Options / Padding**: 확장 헤더로 대체

**IPv6 기본 헤더 구성 (40바이트 고정):**
- Version (4비트): 항상 6
- Traffic Class (8비트): QoS용
- Flow Label (20비트): 동일 흐름의 패킷 식별
- Payload Length (16비트): 페이로드 크기
- Next Header (8비트): 다음 헤더 유형 (확장 헤더 또는 상위 프로토콜)
- Hop Limit (8비트): IPv4의 TTL과 동일한 역할
- Source Address (128비트)
- Destination Address (128비트)

Header Checksum이 제거된 것이 라우터 성능 향상에 크게 기여합니다. IPv4에서는 TTL이 변경될 때마다 매 홉에서 체크섬을 재계산해야 했습니다.

---

### 면접관: "IPv6에서 프리픽스 길이(prefix length)는 어떻게 표기하고, /64라는 값은 어떤 의미가 있나요?"

IPv6에서도 IPv4의 서브넷 마스크와 유사하게 프리픽스 길이(Prefix Length)를 슬래시 표기법으로 사용합니다.

```
2001:DB8:ABCD:1234::1/64
```

여기서 `/64`는 앞의 64비트가 네트워크 부분(프리픽스)이고, 나머지 64비트가 인터페이스 ID(호스트 부분)라는 의미입니다.

**IPv6 주소 구조 (/64 기준):**
```
|<----------- 64비트 ----------->|<----------- 64비트 ----------->|
|         네트워크 프리픽스         |         인터페이스 ID           |
|  Global Routing Prefix + SID   |        Interface ID            |
```

/64가 가장 일반적으로 사용되는 이유는 다음과 같습니다:

1. **SLAAC 동작 요구사항**: SLAAC(Stateless Address Autoconfiguration)가 정상 동작하려면 인터페이스 ID가 64비트여야 합니다
2. **EUI-64 호환성**: MAC 주소(48비트)를 기반으로 64비트 인터페이스 ID를 생성하는 EUI-64 방식과 호환됩니다
3. **표준 권고사항**: RFC 6164를 제외하면, 일반적인 LAN 세그먼트에는 /64를 사용하는 것이 권고됩니다

다만, 포인트-투-포인트 링크에서는 /127을 사용하기도 하며, 루프백에는 /128을 사용합니다.

---

### 면접관: "인터페이스 ID는 어떻게 생성되나요? EUI-64 방식에 대해 설명해 주세요."

인터페이스 ID를 생성하는 방법은 여러 가지가 있습니다.

**1. EUI-64 (Extended Unique Identifier 64-bit)**

MAC 주소(48비트)를 기반으로 64비트 인터페이스 ID를 자동 생성하는 방식입니다.

과정은 다음과 같습니다:

```
1단계: MAC 주소 분리
   MAC: 00:11:22:33:44:55
   앞 24비트(OUI): 00:11:22
   뒤 24비트:      33:44:55

2단계: 중간에 FF:FE 삽입
   00:11:22:FF:FE:33:44:55

3단계: 7번째 비트 반전 (U/L 비트)
   00 → 02 (0000 0000 → 0000 0010)
   결과: 02:11:22:FF:FE:33:44:55

최종 인터페이스 ID: 0211:22FF:FE33:4455
```

**2. 수동 설정**: 관리자가 직접 인터페이스 ID를 지정

```
Router(config-if)# ipv6 address 2001:DB8:1::1/64
```

**3. 랜덤 생성**: 개인정보 보호를 위해 임의의 인터페이스 ID 사용 (RFC 4941)

EUI-64 방식은 MAC 주소가 포함되어 있어 장치를 추적할 수 있다는 보안 우려가 있습니다. 그래서 최근 운영체제들은 기본적으로 랜덤 인터페이스 ID를 사용하는 경향이 있습니다.

---

### 면접관: "실제로 라우터에서 IPv6 주소를 확인하는 명령어는 무엇이며, 출력 결과를 어떻게 해석하나요?"

라우터에서 IPv6 주소를 확인하는 기본 명령어는 다음과 같습니다.

```
Router# show ipv6 interface brief
```

출력 예시:

```
Interface          Status    IPv6 Address
GigabitEthernet0/0 [up/up]   FE80::211:22FF:FE33:4455
                              2001:DB8:ABCD:1::1
GigabitEthernet0/1 [up/up]   FE80::211:22FF:FE33:4456
                              2001:DB8:ABCD:2::1
Loopback0          [up/up]   FE80::1
                              2001:DB8:ABCD:FF::1
```

더 상세한 정보를 보려면 다음 명령어를 사용합니다:

```
Router# show ipv6 interface GigabitEthernet0/0
```

이 명령어의 출력에서 확인할 수 있는 정보:
- **Link-Local 주소**: FE80으로 시작하는 주소 (자동 생성)
- **Global Unicast 주소**: 2001:DB8으로 시작하는 주소 (설정된 글로벌 주소)
- **Joined Group 주소**: 해당 인터페이스가 참여한 멀티캐스트 그룹
- **MTU 정보**: 기본 1500바이트
- **ND(Neighbor Discovery) 관련 정보**

기본적인 IPv6 설정 명령어는 다음과 같습니다:

```
Router(config)# ipv6 unicast-routing
Router(config)# interface GigabitEthernet0/0
Router(config-if)# ipv6 address 2001:DB8:ABCD:1::1/64
Router(config-if)# no shutdown
```

`ipv6 unicast-routing` 명령어는 라우터에서 IPv6 라우팅을 활성화하는 데 필수적이며, 이 명령어 없이는 라우터가 IPv6 패킷을 전달하지 않습니다.

---

### 면접관: "마지막으로, IPv6 도입이 왜 필요한지 비즈니스 관점에서 정리해 주시겠습니까?"

IPv6 도입이 필요한 이유를 기술적, 비즈니스 관점에서 정리하겠습니다.

**기술적 필요성:**
1. **IPv4 주소 고갈**: IANA의 IPv4 주소 풀은 이미 소진되었으며, 지역 인터넷 레지스트리(RIR)에서도 잔여 주소가 거의 없습니다
2. **NAT의 한계**: NAT로 주소 부족을 완화해 왔지만, 엔드투엔드 연결성이 깨지고, 일부 애플리케이션에서 문제가 발생합니다
3. **IoT 확산**: 수십억 개의 IoT 기기가 네트워크에 연결되면서 주소 수요가 급증하고 있습니다

**비즈니스 관점:**
1. **미래 호환성**: 주요 클라우드 서비스와 콘텐츠 제공업체가 이미 IPv6를 지원하고 있으며, 향후 IPv6 전용 서비스가 늘어날 수 있습니다
2. **비용 절감**: NAT 장비의 관리 복잡성과 성능 오버헤드를 줄일 수 있습니다
3. **성능 향상**: 단순화된 헤더로 라우터 처리 효율이 개선되고, NAT 변환 지연이 없어집니다
4. **보안 강화**: IPsec 기본 지원으로 엔드투엔드 암호화가 용이합니다

다만, 즉시 전면 전환보다는 듀얼 스택(Dual-Stack) 방식으로 점진적으로 도입하는 것이 실무에서 권장되는 접근법입니다.
