# 01-02. TCP와 UDP

> CCNA 200-301 수준의 네트워크 엔지니어 면접 시나리오입니다.
> TCP와 UDP의 특성, 3-way/4-way handshake, 흐름 제어, 포트 번호, TCP 플래그 등을 다룹니다.

---

### 면접관: "TCP와 UDP의 차이점을 설명해 주세요. 각각 어떤 상황에서 사용하는지도 함께 말씀해 주세요."

TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 모두 전송 계층(Layer 4) 프로토콜이지만, 근본적인 설계 철학이 다릅니다.

| 특성 | TCP | UDP |
|------|-----|-----|
| 연결 방식 | 연결 지향 (Connection-Oriented) | 비연결 (Connectionless) |
| 신뢰성 | 높음 (재전송, 순서 보장) | 낮음 (재전송 없음) |
| 순서 보장 | O (시퀀스 번호 사용) | X |
| 흐름 제어 | O (윈도우 사이즈) | X |
| 혼잡 제어 | O | X |
| 헤더 크기 | 20~60 바이트 | 8 바이트 |
| 속도 | 상대적으로 느림 | 상대적으로 빠름 |
| 사용 예시 | HTTP, FTP, SSH, SMTP | DNS, DHCP, VoIP, 동영상 스트리밍 |

**TCP를 사용하는 경우:**
- 데이터 손실이 허용되지 않는 서비스 (웹, 파일 전송, 이메일)
- 데이터 순서가 중요한 경우

**UDP를 사용하는 경우:**
- 실시간성이 중요한 서비스 (VoIP, 영상 통화, 온라인 게임)
- 약간의 데이터 손실이 허용되는 경우
- DNS 질의처럼 단일 요청/응답 형태의 간단한 통신

한 가지 주의할 점은 DNS의 경우, 일반적인 질의는 UDP 53번을 사용하지만 존 전송(Zone Transfer)시에는 TCP 53번을 사용합니다.

---

### 면접관: "TCP의 3-way handshake 과정을 자세히 설명해 주세요. 각 단계에서 어떤 플래그가 사용되나요?"

TCP 3-way handshake는 TCP 연결을 수립하기 위한 3단계 과정입니다. 이 과정을 통해 양측이 통신 준비가 되었음을 확인합니다.

**3-way handshake 과정:**

```
클라이언트                          서버
   |                                 |
   |  1) SYN (seq=100)              |
   |  -----------------------------> |
   |                                 |
   |  2) SYN+ACK (seq=300, ack=101) |
   |  <-----------------------------  |
   |                                 |
   |  3) ACK (seq=101, ack=301)     |
   |  -----------------------------> |
   |                                 |
   |      [연결 수립 완료]            |
```

**각 단계 상세 설명:**

1. **SYN (Synchronize)**: 클라이언트가 서버에게 연결 요청을 보냅니다. 클라이언트의 초기 시퀀스 번호(ISN)를 포함합니다. 이때 클라이언트 상태는 `SYN_SENT`가 됩니다.

2. **SYN+ACK**: 서버가 클라이언트의 요청을 수락하며 응답합니다. 서버의 ISN과 함께 클라이언트의 시퀀스 번호에 1을 더한 ACK 번호를 보냅니다. 서버 상태는 `SYN_RECEIVED`가 됩니다.

3. **ACK (Acknowledge)**: 클라이언트가 서버의 응답을 확인합니다. 이 패킷이 도착하면 양측 모두 `ESTABLISHED` 상태가 되어 데이터 전송이 시작됩니다.

#### 실무 확인 방법

```
# 패킷 캡처로 3-way handshake 확인
PC> wireshark  (필터: tcp.flags.syn==1)

# 현재 TCP 연결 상태 확인
PC> netstat -an | findstr ESTABLISHED
PC> netstat -an | findstr SYN_SENT
```

---

### 면접관: "TCP 연결 종료 과정인 4-way termination도 설명해 주세요. 왜 3-way가 아니라 4-way인가요?"

TCP 연결 종료는 4-way termination(또는 4-way handshake)이라고 하며, 양쪽에서 각각 FIN을 보내야 하기 때문에 4단계가 필요합니다.

**4-way termination 과정:**

```
클라이언트                          서버
   |                                 |
   |  1) FIN (seq=500)              |
   |  -----------------------------> |
   |                                 |
   |  2) ACK (ack=501)              |
   |  <-----------------------------  |
   |                                 |
   |  (서버가 남은 데이터 전송 완료)  |
   |                                 |
   |  3) FIN (seq=700)              |
   |  <-----------------------------  |
   |                                 |
   |  4) ACK (ack=701)              |
   |  -----------------------------> |
   |                                 |
   |    [연결 종료 완료]              |
```

**왜 4단계인가:**

3-way handshake에서는 서버가 SYN과 ACK를 하나의 패킷에 합쳐서 보낼 수 있었습니다. 그러나 연결 종료 시에는 상황이 다릅니다. 서버가 클라이언트의 FIN을 받더라도 아직 보낼 데이터가 남아있을 수 있기 때문에, ACK와 FIN을 별도로 보내야 합니다.

**각 단계의 상태 변화:**

| 단계 | 클라이언트 상태 | 서버 상태 |
|------|----------------|-----------|
| 초기 | ESTABLISHED | ESTABLISHED |
| FIN 전송 후 | FIN_WAIT_1 | CLOSE_WAIT |
| ACK 수신 후 | FIN_WAIT_2 | CLOSE_WAIT |
| 서버 FIN 수신 후 | TIME_WAIT | LAST_ACK |
| 최종 ACK 전송 후 | TIME_WAIT → CLOSED | CLOSED |

`TIME_WAIT` 상태는 보통 2MSL(Maximum Segment Lifetime) 동안 유지됩니다. 이는 마지막 ACK가 손실되었을 때를 대비하여 재전송할 수 있도록 하기 위함입니다.

---

### 면접관: "TCP의 주요 플래그들을 설명해 주세요. 각 플래그가 어떤 상황에서 사용되나요?"

TCP 헤더에는 6개의 주요 제어 플래그(Control Flags)가 있습니다.

| 플래그 | 이름 | 역할 | 사용 상황 |
|--------|------|------|-----------|
| **SYN** | Synchronize | 연결 수립 요청 | 3-way handshake의 1, 2단계 |
| **ACK** | Acknowledge | 수신 확인 | 데이터 수신 확인, 거의 모든 패킷에 포함 |
| **FIN** | Finish | 연결 종료 요청 | 4-way termination의 1, 3단계 |
| **RST** | Reset | 연결 강제 리셋 | 비정상 종료, 존재하지 않는 포트 접근 시 |
| **PSH** | Push | 버퍼링 없이 즉시 전달 | 대화형 통신 (SSH, Telnet) |
| **URG** | Urgent | 긴급 데이터 표시 | 긴급 데이터 전송 시 (드물게 사용) |

**RST 플래그가 발생하는 대표적 상황:**

- 서버에서 해당 포트가 열려있지 않을 때
- 방화벽이 연결을 차단할 때
- 비정상적인 패킷을 수신했을 때
- 이미 종료된 연결에 대한 패킷이 도착했을 때

```
# Wireshark 필터로 RST 패킷 확인
tcp.flags.reset == 1

# SYN 패킷만 필터링 (연결 시도 확인)
tcp.flags.syn == 1 && tcp.flags.ack == 0
```

---

### 면접관: "TCP의 흐름 제어(Flow Control)와 윈도우 사이즈(Window Size)에 대해 설명해 주세요."

TCP 흐름 제어는 송신 측이 수신 측의 처리 능력을 초과하지 않도록 전송 속도를 조절하는 메커니즘입니다. 이를 위해 **슬라이딩 윈도우(Sliding Window)** 방식을 사용합니다.

**윈도우 사이즈(Window Size)란:**
- 수신 측이 한 번에 받을 수 있는 데이터의 양(바이트 단위)을 의미합니다.
- TCP 헤더의 Window Size 필드에 표시됩니다.
- 수신 측은 자신의 버퍼 여유 공간에 따라 윈도우 사이즈를 동적으로 조절합니다.

**동작 원리:**

```
송신 측                              수신 측
   |                                   |
   | [데이터 1000B] Window=4000       |
   | --------------------------------> |
   | [데이터 1000B]                    |
   | --------------------------------> |
   |                                   |
   |       ACK, Window=2000            |
   | <-------------------------------- |
   |  (수신 버퍼 여유 공간이 줄어듦)     |
   |                                   |
   | [데이터 1000B]                    |
   | --------------------------------> |
   |                                   |
   |       ACK, Window=0              |
   | <-------------------------------- |
   |  (수신 버퍼 가득 참 → 전송 중지)   |
   |                                   |
   |       ACK, Window=4000            |
   | <-------------------------------- |
   |  (버퍼 비워짐 → 전송 재개)         |
```

윈도우 사이즈가 0이 되면 송신 측은 데이터 전송을 중단하고, 수신 측이 버퍼를 처리한 후 새로운 윈도우 사이즈를 알려줄 때까지 대기합니다.

---

### 면접관: "Well-known 포트 번호에 대해 설명해 주세요. 면접에서 자주 물어보는 포트 번호를 알려주세요."

포트 번호는 0~65535 범위이며, 세 가지 범위로 구분됩니다.

| 범위 | 이름 | 용도 |
|------|------|------|
| 0~1023 | Well-known Ports | 표준 서비스용 (관리자 권한 필요) |
| 1024~49151 | Registered Ports | 등록된 애플리케이션용 |
| 49152~65535 | Dynamic/Private Ports | 클라이언트 임시 포트 |

#### 반드시 알아야 할 Well-known 포트

| 포트 번호 | 프로토콜 | 서비스 | 전송 프로토콜 |
|-----------|----------|--------|---------------|
| 20 | FTP Data | FTP 데이터 전송 | TCP |
| 21 | FTP Control | FTP 제어 연결 | TCP |
| 22 | SSH | 보안 원격 접속 | TCP |
| 23 | Telnet | 원격 접속 (비암호화) | TCP |
| 25 | SMTP | 이메일 발송 | TCP |
| 53 | DNS | 도메인 이름 해석 | TCP/UDP |
| 67/68 | DHCP | IP 자동 할당 (서버/클라이언트) | UDP |
| 69 | TFTP | 간이 파일 전송 | UDP |
| 80 | HTTP | 웹 서비스 | TCP |
| 110 | POP3 | 이메일 수신 | TCP |
| 143 | IMAP | 이메일 수신 (서버 동기화) | TCP |
| 161/162 | SNMP | 네트워크 관리 (에이전트/트랩) | UDP |
| 443 | HTTPS | 보안 웹 서비스 | TCP |

#### 실무 포트 확인 명령어

```
# Windows에서 열린 포트 확인
C:\> netstat -an
C:\> netstat -ano | findstr :80

# Linux에서 열린 포트 확인
$ ss -tulnp
$ netstat -tulnp

# Cisco 장비에서 접근 확인
Router# show control-plane host open-ports
```

---

### 면접관: "TCP에서 데이터가 손실되었을 때 어떻게 복구하나요? 재전송 메커니즘을 설명해 주세요."

TCP는 데이터 손실 시 **재전송(Retransmission)** 메커니즘을 통해 신뢰성을 보장합니다. 주요 재전송 방식은 두 가지입니다.

**1. 타임아웃 기반 재전송 (RTO: Retransmission Timeout)**

송신 측은 세그먼트를 보낸 후 타이머를 시작합니다. 일정 시간(RTO) 내에 ACK를 받지 못하면 해당 세그먼트를 재전송합니다.

```
송신 측                              수신 측
   |                                   |
   | [Seq=100, Data]                   |
   | --------------------------------> |
   |                                   |
   | [Seq=200, Data]                   |
   | --------X (손실)                  |
   |                                   |
   | [Seq=300, Data]                   |
   | --------------------------------> |
   |                                   |
   |  (RTO 타이머 만료)                 |
   |                                   |
   | [Seq=200, Data] (재전송)          |
   | --------------------------------> |
```

**2. 빠른 재전송 (Fast Retransmission)**

수신 측이 순서가 맞지 않는 세그먼트를 받으면 중복 ACK를 보냅니다. 송신 측이 동일한 ACK를 **3번** 연속으로 받으면(총 3 Duplicate ACK) 타이머 만료를 기다리지 않고 즉시 재전송합니다.

```
송신 측                              수신 측
   |                                   |
   | [Seq=100]  → ACK=200             |
   | [Seq=200]  → (손실)               |
   | [Seq=300]  → ACK=200 (중복 1)    |
   | [Seq=400]  → ACK=200 (중복 2)    |
   | [Seq=500]  → ACK=200 (중복 3)    |
   |                                   |
   | 3 Duplicate ACK 감지!             |
   | [Seq=200] 즉시 재전송              |
   | --------------------------------> |
```

빠른 재전송은 RTO 타이머 만료를 기다리는 것보다 훨씬 빠르게 손실된 데이터를 복구할 수 있어서, 네트워크 성능 향상에 크게 기여합니다.

---

### 면접관: "실무에서 TCP 연결 문제를 진단할 때 어떻게 접근하시나요?"

TCP 연결 문제 진단 시 다음과 같은 순서로 접근합니다.

#### 1단계: 연결 상태 확인

```
# TCP 연결 상태별 확인
C:\> netstat -an | findstr ESTABLISHED    # 정상 연결
C:\> netstat -an | findstr SYN_SENT       # 연결 시도 중 (상대방 응답 없음)
C:\> netstat -an | findstr CLOSE_WAIT     # 상대방이 종료했지만 로컬에서 미처리
C:\> netstat -an | findstr TIME_WAIT      # 연결 종료 대기 중
```

#### 2단계: 포트 연결성 테스트

```
# 특정 포트 접근 가능 여부 확인
C:\> telnet 10.0.0.1 80
C:\> Test-NetConnection 10.0.0.1 -Port 80   # PowerShell

# Linux
$ nc -zv 10.0.0.1 80
$ curl -v http://10.0.0.1
```

#### 3단계: 패킷 캡처 분석

패킷 캡처를 통해 3-way handshake가 정상적으로 완료되는지, RST 패킷이 발생하는지, 재전송이 과도하게 발생하는지 등을 확인합니다.

**흔한 TCP 문제와 원인:**

| 증상 | 가능한 원인 |
|------|------------|
| SYN_SENT 상태 지속 | 방화벽 차단, 서버 다운 |
| CLOSE_WAIT 다수 | 애플리케이션에서 소켓 미종료 |
| TIME_WAIT 다수 | 짧은 연결이 빈번한 경우 (정상일 수 있음) |
| RST 패킷 빈번 | 서비스 미실행, ACL 차단 |
| 재전송 빈번 | 네트워크 혼잡, 패킷 손실 |

이러한 체계적인 접근을 통해 TCP 연결 문제의 원인을 신속하게 파악할 수 있습니다.
