# 02-02. Static Routing과 Default Route

> CCNA 200-301 라우팅 기초 면접 시나리오
> 주제: 정적 라우팅 설정, 디폴트 라우트, next-hop과 exit interface, 검증 명령어

---

### 면접관: "정적 라우팅(Static Routing)이 무엇인지 설명하고, 어떤 상황에서 사용하는 것이 적합한지 말씀해주세요."

정적 라우팅은 관리자가 수동으로 라우팅 테이블에 경로를 입력하는 방식입니다. 동적 라우팅 프로토콜(OSPF, EIGRP 등)처럼 자동으로 경로를 학습하지 않고, 관리자가 목적지 네트워크, 서브넷 마스크, 다음 홉(next-hop) 또는 출구 인터페이스를 직접 지정합니다.

정적 라우팅이 적합한 상황은 다음과 같습니다:

- **스텁 네트워크 (Stub Network)**: 외부로 나가는 경로가 하나뿐인 네트워크에서 사용합니다. 예를 들어 지사 라우터가 본사와 한 개의 WAN 링크로만 연결된 경우입니다.
- **소규모 네트워크**: 라우터가 2~3대인 소규모 환경에서는 동적 라우팅 프로토콜의 오버헤드가 불필요합니다.
- **ISP 연결**: 인터넷 서비스 제공업체와 연결할 때 디폴트 라우트로 설정합니다.
- **보안 목적**: 특정 경로만 허용하고 싶을 때 정적 라우트를 사용할 수 있습니다.
- **백업 경로**: Floating Static Route로 동적 라우팅의 백업 경로를 구성할 때 사용합니다.

| 항목 | 정적 라우팅 | 동적 라우팅 |
|------|-----------|-----------|
| 설정 방식 | 관리자 수동 입력 | 프로토콜이 자동 학습 |
| CPU/메모리 사용 | 적음 | 상대적으로 많음 |
| 대역폭 사용 | 없음 | 라우팅 업데이트 패킷 사용 |
| 확장성 | 낮음 (대규모 부적합) | 높음 |
| 장애 시 대응 | 수동 변경 필요 | 자동 경로 재계산 |
| Administrative Distance | 1 | 프로토콜마다 다름 |

---

### 면접관: "정적 라우트를 설정하는 명령어의 문법을 설명해주세요. next-hop IP를 지정하는 방식과 exit interface를 지정하는 방식의 차이가 무엇입니까?"

정적 라우트의 기본 문법은 다음과 같습니다:

```
ip route [목적지 네트워크] [서브넷 마스크] [next-hop IP 또는 exit interface]
```

세 가지 설정 방식이 있습니다:

```
! 방법 1: Next-hop IP 지정 (권장)
R1(config)# ip route 192.168.20.0 255.255.255.0 10.0.0.2

! 방법 2: Exit interface 지정
R1(config)# ip route 192.168.20.0 255.255.255.0 GigabitEthernet0/1

! 방법 3: Exit interface + Next-hop IP (완전 지정, Fully Specified)
R1(config)# ip route 192.168.20.0 255.255.255.0 GigabitEthernet0/1 10.0.0.2
```

**Next-hop IP 방식**:
- 라우터가 라우팅 테이블에서 next-hop IP에 도달하는 방법을 한 번 더 조회합니다(재귀 조회, recursive lookup).
- 멀티액세스 네트워크(이더넷)에서 정상적으로 ARP를 수행하여 next-hop의 MAC 주소를 알아냅니다.

**Exit interface 방식**:
- 재귀 조회가 필요 없어 처리가 빠릅니다.
- Point-to-Point 링크(시리얼 등)에서는 문제 없지만, 멀티액세스 네트워크(이더넷)에서는 모든 목적지에 대해 ARP 요청을 보내게 되어 비효율적입니다.

**Fully Specified 방식**:
- exit interface와 next-hop IP를 모두 지정하여 재귀 조회도 없고, 멀티액세스 네트워크에서도 올바르게 동작합니다.
- 가장 정확하고 안전한 방식입니다.

---

### 면접관: "Default Route는 무엇이며, 왜 필요합니까? 실제 설정 예시를 보여주세요."

Default Route는 라우팅 테이블에서 특정 목적지와 일치하는 경로를 찾지 못했을 때 사용하는 마지막 경로입니다. 목적지를 `0.0.0.0/0`으로 표기하며, 이는 모든 네트워크를 의미합니다. "Gateway of Last Resort"라고도 불립니다.

Default Route가 필요한 이유는 인터넷에 연결할 때 인터넷의 모든 경로를 라우팅 테이블에 가지고 있을 수 없기 때문입니다. 현재 인터넷 BGP 풀 라우팅 테이블은 90만 개 이상의 경로를 포함하고 있어, 일반 기업 라우터에서 이를 모두 관리하는 것은 비현실적입니다.

```
! 시나리오: R1이 ISP 라우터(203.0.113.1)를 통해 인터넷에 접속
R1(config)# ip route 0.0.0.0 0.0.0.0 203.0.113.1
```

검증 방법:

```
R1# show ip route
...
Gateway of last resort is 203.0.113.1 to network 0.0.0.0

S*    0.0.0.0/0 [1/0] via 203.0.113.1
C     192.168.10.0/24 is directly connected, GigabitEthernet0/0
C     203.0.113.0/30 is directly connected, GigabitEthernet0/1
```

출력에서 `S*`는 정적(S) 디폴트 라우트(*)를 의미합니다. `[1/0]`에서 1은 Administrative Distance, 0은 메트릭입니다.

---

### 면접관: "다음 네트워크 구성에서 R1과 R3 사이에 통신이 되도록 정적 라우트를 설정해보세요. R1--R2--R3, 각 라우터 간 네트워크는 10.0.12.0/30과 10.0.23.0/30입니다."

네트워크 구성을 정리하면 다음과 같습니다:

```
[R1 LAN: 192.168.10.0/24]
  |
R1 (Gi0/0: 192.168.10.1) (Gi0/1: 10.0.12.1)
  |
  | 10.0.12.0/30
  |
R2 (Gi0/0: 10.0.12.2) (Gi0/1: 10.0.23.1)
  |
  | 10.0.23.0/30
  |
R3 (Gi0/0: 10.0.23.2) (Gi0/1: 192.168.30.1)
  |
[R3 LAN: 192.168.30.0/24]
```

각 라우터의 정적 라우트 설정입니다:

```
! R1 설정 - R3 LAN과 R2-R3 구간 경로 추가
R1(config)# ip route 192.168.30.0 255.255.255.0 10.0.12.2
R1(config)# ip route 10.0.23.0 255.255.252.0 10.0.12.2

! R2 설정 - 양쪽 LAN 네트워크 경로 추가
R2(config)# ip route 192.168.10.0 255.255.255.0 10.0.12.1
R2(config)# ip route 192.168.30.0 255.255.255.0 10.0.23.2

! R3 설정 - R1 LAN과 R1-R2 구간 경로 추가
R3(config)# ip route 192.168.10.0 255.255.255.0 10.0.23.1
R3(config)# ip route 10.0.12.0 255.255.255.252 10.0.23.1
```

중요한 점은 정적 라우팅에서는 양방향 모두 설정해야 한다는 것입니다. R1에서 R3로 가는 경로만 설정하고 R3에서 R1으로 돌아오는 경로를 설정하지 않으면, ping은 도달하지만 응답이 돌아오지 못합니다. 이것은 초보 엔지니어가 흔히 하는 실수입니다.

---

### 면접관: "show ip route 명령어의 출력에서 각 기호(C, L, S, S*)의 의미를 설명해주세요."

```
R1# show ip route
Codes: L - local, C - connected, S - static, R - RIP,
       O - OSPF, D - EIGRP, B - BGP
       * - candidate default

Gateway of last resort is 203.0.113.1 to network 0.0.0.0

S*    0.0.0.0/0 [1/0] via 203.0.113.1
      10.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C        10.0.12.0/30 is directly connected, GigabitEthernet0/1
L        10.0.12.1/32 is directly connected, GigabitEthernet0/1
      192.168.10.0/24 is variably subnetted, 2 subnets, 2 masks
C        192.168.10.0/24 is directly connected, GigabitEthernet0/0
L        192.168.10.1/32 is directly connected, GigabitEthernet0/0
S     192.168.30.0/24 [1/0] via 10.0.12.2
```

각 기호의 의미는 다음과 같습니다:

| 기호 | 의미 | 설명 |
|------|------|------|
| C | Connected | 직접 연결된 네트워크 (인터페이스에 IP 설정 시 자동 생성) |
| L | Local | 인터페이스 자체 IP 주소 (/32 호스트 경로) |
| S | Static | 관리자가 수동으로 설정한 정적 경로 |
| S* | Static Default | 정적으로 설정된 디폴트 라우트 (candidate default) |
| O | OSPF | OSPF로 학습한 경로 |
| D | EIGRP | EIGRP로 학습한 경로 |

`[1/0]`에서 대괄호 안의 첫 번째 숫자는 Administrative Distance(AD), 두 번째 숫자는 메트릭(Metric)입니다. 정적 라우트의 AD는 기본값이 1이며, Connected는 0입니다.

`L` 경로는 IOS 15부터 표시되는데, 라우터 자기 자신의 IP 주소를 /32로 보여줍니다. 이 경로 덕분에 라우터는 자신에게 들어오는 패킷을 정확하게 처리할 수 있습니다.

---

### 면접관: "재귀 정적 라우트(Recursive Static Route)와 직접 연결 정적 라우트(Directly Connected Static Route)의 차이를 설명해주세요."

**직접 연결 정적 라우트 (Directly Connected Static Route)**:
next-hop IP가 라우터에 직접 연결된(Connected) 네트워크에 속하는 경우입니다.

```
! R1의 Gi0/1이 10.0.12.0/30에 연결되어 있고,
! next-hop 10.0.12.2는 이 Connected 네트워크에 속함
R1(config)# ip route 192.168.30.0 255.255.255.0 10.0.12.2
```

이 경우 라우터는 10.0.12.2가 직접 연결된 네트워크에 있으므로, 한 번의 조회로 출구 인터페이스를 결정할 수 있습니다.

**재귀 정적 라우트 (Recursive Static Route)**:
next-hop IP가 직접 연결된 네트워크가 아닌, 라우팅 테이블에서 다시 조회해야 하는 경우입니다.

```
! R1에서 172.16.0.0/16으로 가려면 next-hop이 10.0.23.2인데,
! 10.0.23.2는 R1에 직접 연결되지 않음
R1(config)# ip route 172.16.0.0 255.255.0.0 10.0.23.2
```

이 경우 라우터는 다음 과정을 거칩니다:
1. 172.16.0.0/16의 next-hop이 10.0.23.2임을 확인
2. 10.0.23.2에 도달하는 방법을 라우팅 테이블에서 다시 조회 (재귀 조회)
3. 10.0.23.0/30이 10.0.12.2를 통해 도달 가능함을 확인
4. 10.0.12.2가 Gi0/1 인터페이스의 Connected 네트워크에 속함을 확인
5. 최종적으로 Gi0/1을 통해 패킷 전송

재귀 조회는 추가적인 라우팅 테이블 검색이 필요하므로 약간의 처리 지연이 발생할 수 있습니다. 그래서 가능하면 next-hop IP는 직접 연결된 네트워크의 주소를 사용하는 것이 좋습니다.

---

### 면접관: "정적 라우팅의 한계가 무엇이며, 어떤 경우에 동적 라우팅으로 전환해야 합니까?"

정적 라우팅의 주요 한계는 다음과 같습니다:

**1. 확장성 부족**
네트워크가 커질수록 관리해야 할 정적 경로의 수가 급격히 증가합니다. 라우터 N대가 있으면 최악의 경우 각 라우터마다 N-1개 이상의 경로를 관리해야 합니다.

**2. 자동 장애 복구 불가**
경로에 장애가 발생해도 정적 라우트는 자동으로 대체 경로를 찾지 못합니다. 관리자가 수동으로 경로를 변경하거나, Floating Static Route를 미리 구성해두어야 합니다.

**3. 운영 부담 증가**
네트워크 변경 시 관련된 모든 라우터의 정적 경로를 수동으로 업데이트해야 하며, 하나라도 빠뜨리면 통신 장애가 발생합니다.

**동적 라우팅으로 전환해야 하는 시점:**

- 라우터가 5대 이상인 중규모 이상 네트워크
- 이중화 경로가 필요하고 자동 페일오버가 요구되는 환경
- 네트워크 구조가 자주 변경되는 환경
- 운영 인력이 한정된 환경

실무에서는 정적 라우팅과 동적 라우팅을 혼합하여 사용하는 경우가 많습니다. 예를 들어 내부 네트워크는 OSPF로 운용하고, ISP 연결은 디폴트 정적 라우트로 설정하는 것이 일반적인 패턴입니다.
